<?xml version="1.0" encoding="UTF-8" ?>
<class name="OpenXRMetaEnvironmentDepthExtensionWrapper" inherits="OpenXRExtensionWrapperExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
		Wraps the [code]XR_META_environment_depth[/code] extension.
	</brief_description>
	<description>
		Wraps the [code]XR_META_environment_depth[/code] extension.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="get_environment_depth_map_async">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<description>
				Requests that the environment depth map data (including the image data) be sent to the given callback for use on the CPU.
				This can be used for things like implementing your own realtime plane tracking.
				The callback will be called with an array of two dictionaries (one for each eye), containing:
				- [b]depth_projection_view[/b]: ([Projection]) The projection view matrix for the depth map.
				- [b]depth_inverse_projection_view[/b]: ([Projection]) The inverse projection view matrix for the depth map.
				- [b]image[/b]: ([Image]) The depth map image data.
				This method should be called sparingly, and definitely not on every frame. First of all, the depth map image isn't updated every frame - it's closer to every 2-4 frames, depending on the display's refresh rate. But, also, the depth map is provided to us as GPU resource that we need to download to the CPU, which isn't the fastest operation. It would be reasonable to call this from a timer that goes off every 1 second, for example.
				If you need to use the depth map for rendering, it's recommended that you do so from a shader (instead of using this method), which will be able to access the depth map texture on the GPU directly via global shader uniforms, as well as up-to-date projection information for use on the current frame.
			</description>
		</method>
		<method name="get_hand_removal_enabled" qualifiers="const">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if hand removal is enabled; otherwise, [code]false[/code].
			</description>
		</method>
		<method name="is_environment_depth_started">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if environment depth has been started; otherwise, [code]false[/code].
			</description>
		</method>
		<method name="is_environment_depth_supported">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if environment depth is supported; otherwise, [code]false[/code].
			</description>
		</method>
		<method name="is_hand_removal_supported">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if hand removal is supported; otherwise, [code]false[/code].
			</description>
		</method>
		<method name="set_hand_removal_enabled">
			<return type="void" />
			<param index="0" name="enable" type="bool" />
			<description>
				Enables or disables hand removal.
				When enabled, the runtime will attempt to remove the user's hands from the environment depth data. However, this will only work if hand tracking is enabled and the user isn't using controllers.
			</description>
		</method>
		<method name="start_environment_depth">
			<return type="void" />
			<description>
				Starts environment depth.
			</description>
		</method>
		<method name="stop_environment_depth">
			<return type="void" />
			<description>
				Stops environment depth.
			</description>
		</method>
	</methods>
	<signals>
		<signal name="openxr_meta_environment_depth_started">
			<description>
				Emitted after environment depth successfully starts.
			</description>
		</signal>
		<signal name="openxr_meta_environment_depth_stopped">
			<description>
				Emitted after environment depth successfully stops.
			</description>
		</signal>
	</signals>
</class>
